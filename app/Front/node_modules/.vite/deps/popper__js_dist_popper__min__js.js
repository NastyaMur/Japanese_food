import "./chunk-OL3AADLO.js";

// node_modules/popper.js/dist/popper.min.js
var e = "undefined" != typeof window && "undefined" != typeof document && "undefined" != typeof navigator;
var t = function() {
  const t2 = ["Edge", "Trident", "Firefox"];
  for (let o2 = 0; o2 < t2.length; o2 += 1)
    if (e && 0 <= navigator.userAgent.indexOf(t2[o2]))
      return 1;
  return 0;
}();
function o(e2) {
  let t2 = false;
  return () => {
    t2 || (t2 = true, window.Promise.resolve().then(() => {
      t2 = false, e2();
    }));
  };
}
function n(e2) {
  let o2 = false;
  return () => {
    o2 || (o2 = true, setTimeout(() => {
      o2 = false, e2();
    }, t));
  };
}
var i = e && window.Promise;
var r = i ? o : n;
function p(e2) {
  return e2 && "[object Function]" === {}.toString.call(e2);
}
function d(e2, t2) {
  if (1 !== e2.nodeType)
    return [];
  const o2 = e2.ownerDocument.defaultView, n2 = o2.getComputedStyle(e2, null);
  return t2 ? n2[t2] : n2;
}
function s(e2) {
  return "HTML" === e2.nodeName ? e2 : e2.parentNode || e2.host;
}
function f(e2) {
  if (!e2)
    return document.body;
  switch (e2.nodeName) {
    case "HTML":
    case "BODY":
      return e2.ownerDocument.body;
    case "#document":
      return e2.body;
  }
  const { overflow: t2, overflowX: o2, overflowY: n2 } = d(e2);
  return /(auto|scroll|overlay)/.test(t2 + n2 + o2) ? e2 : f(s(e2));
}
function a(e2) {
  return e2 && e2.referenceNode ? e2.referenceNode : e2;
}
var l = e && !!(window.MSInputMethodContext && document.documentMode);
var m = e && /MSIE 10/.test(navigator.userAgent);
function h(e2) {
  return 11 === e2 ? l : 10 === e2 ? m : l || m;
}
function c(e2) {
  if (!e2)
    return document.documentElement;
  const t2 = h(10) ? document.body : null;
  let o2 = e2.offsetParent || null;
  for (; o2 === t2 && e2.nextElementSibling; )
    o2 = (e2 = e2.nextElementSibling).offsetParent;
  const n2 = o2 && o2.nodeName;
  return n2 && "BODY" !== n2 && "HTML" !== n2 ? -1 !== ["TH", "TD", "TABLE"].indexOf(o2.nodeName) && "static" === d(o2, "position") ? c(o2) : o2 : e2 ? e2.ownerDocument.documentElement : document.documentElement;
}
function u(e2) {
  const { nodeName: t2 } = e2;
  return "BODY" !== t2 && ("HTML" === t2 || c(e2.firstElementChild) === e2);
}
function g(e2) {
  return null === e2.parentNode ? e2 : g(e2.parentNode);
}
function b(e2, t2) {
  if (!e2 || !e2.nodeType || !t2 || !t2.nodeType)
    return document.documentElement;
  const o2 = e2.compareDocumentPosition(t2) & Node.DOCUMENT_POSITION_FOLLOWING, n2 = o2 ? e2 : t2, i2 = o2 ? t2 : e2, r2 = document.createRange();
  r2.setStart(n2, 0), r2.setEnd(i2, 0);
  const { commonAncestorContainer: p2 } = r2;
  if (e2 !== p2 && t2 !== p2 || n2.contains(i2))
    return u(p2) ? p2 : c(p2);
  const d2 = g(e2);
  return d2.host ? b(d2.host, t2) : b(e2, g(t2).host);
}
function w(e2, t2 = "top") {
  const o2 = "top" === t2 ? "scrollTop" : "scrollLeft", n2 = e2.nodeName;
  if ("BODY" === n2 || "HTML" === n2) {
    const t3 = e2.ownerDocument.documentElement, n3 = e2.ownerDocument.scrollingElement || t3;
    return n3[o2];
  }
  return e2[o2];
}
function y(e2, t2, o2 = false) {
  const n2 = w(t2, "top"), i2 = w(t2, "left"), r2 = o2 ? -1 : 1;
  return e2.top += n2 * r2, e2.bottom += n2 * r2, e2.left += i2 * r2, e2.right += i2 * r2, e2;
}
function E(e2, t2) {
  const o2 = "x" === t2 ? "Left" : "Top", n2 = "Left" == o2 ? "Right" : "Bottom";
  return parseFloat(e2[`border${o2}Width`]) + parseFloat(e2[`border${n2}Width`]);
}
function x(e2, t2, o2, n2) {
  return Math.max(t2[`offset${e2}`], t2[`scroll${e2}`], o2[`client${e2}`], o2[`offset${e2}`], o2[`scroll${e2}`], h(10) ? parseInt(o2[`offset${e2}`]) + parseInt(n2[`margin${"Height" === e2 ? "Top" : "Left"}`]) + parseInt(n2[`margin${"Height" === e2 ? "Bottom" : "Right"}`]) : 0);
}
function v(e2) {
  const t2 = e2.body, o2 = e2.documentElement, n2 = h(10) && getComputedStyle(o2);
  return { height: x("Height", t2, o2, n2), width: x("Width", t2, o2, n2) };
}
var O = Object.assign || function(e2) {
  for (var t2, o2 = 1; o2 < arguments.length; o2++)
    for (var n2 in t2 = arguments[o2], t2)
      Object.prototype.hasOwnProperty.call(t2, n2) && (e2[n2] = t2[n2]);
  return e2;
};
function L(e2) {
  return O({}, e2, { right: e2.left + e2.width, bottom: e2.top + e2.height });
}
function S(e2) {
  let t2 = {};
  try {
    if (h(10)) {
      t2 = e2.getBoundingClientRect();
      const o3 = w(e2, "top"), n3 = w(e2, "left");
      t2.top += o3, t2.left += n3, t2.bottom += o3, t2.right += n3;
    } else
      t2 = e2.getBoundingClientRect();
  } catch (t3) {
  }
  const o2 = { left: t2.left, top: t2.top, width: t2.right - t2.left, height: t2.bottom - t2.top }, n2 = "HTML" === e2.nodeName ? v(e2.ownerDocument) : {}, i2 = n2.width || e2.clientWidth || o2.width, r2 = n2.height || e2.clientHeight || o2.height;
  let p2 = e2.offsetWidth - i2, s2 = e2.offsetHeight - r2;
  if (p2 || s2) {
    const t3 = d(e2);
    p2 -= E(t3, "x"), s2 -= E(t3, "y"), o2.width -= p2, o2.height -= s2;
  }
  return L(o2);
}
function T(e2, t2, o2 = false) {
  var n2 = Math.max;
  const i2 = h(10), r2 = "HTML" === t2.nodeName, p2 = S(e2), s2 = S(t2), a2 = f(e2), l2 = d(t2), m2 = parseFloat(l2.borderTopWidth), c2 = parseFloat(l2.borderLeftWidth);
  o2 && r2 && (s2.top = n2(s2.top, 0), s2.left = n2(s2.left, 0));
  let u2 = L({ top: p2.top - s2.top - m2, left: p2.left - s2.left - c2, width: p2.width, height: p2.height });
  if (u2.marginTop = 0, u2.marginLeft = 0, !i2 && r2) {
    const e3 = parseFloat(l2.marginTop), t3 = parseFloat(l2.marginLeft);
    u2.top -= m2 - e3, u2.bottom -= m2 - e3, u2.left -= c2 - t3, u2.right -= c2 - t3, u2.marginTop = e3, u2.marginLeft = t3;
  }
  return (i2 && !o2 ? t2.contains(a2) : t2 === a2 && "BODY" !== a2.nodeName) && (u2 = y(u2, t2)), u2;
}
function D(e2, t2 = false) {
  var o2 = Math.max;
  const n2 = e2.ownerDocument.documentElement, i2 = T(e2, n2), r2 = o2(n2.clientWidth, window.innerWidth || 0), p2 = o2(n2.clientHeight, window.innerHeight || 0), d2 = t2 ? 0 : w(n2), s2 = t2 ? 0 : w(n2, "left"), f2 = { top: d2 - i2.top + i2.marginTop, left: s2 - i2.left + i2.marginLeft, width: r2, height: p2 };
  return L(f2);
}
function C(e2) {
  const t2 = e2.nodeName;
  if ("BODY" === t2 || "HTML" === t2)
    return false;
  if ("fixed" === d(e2, "position"))
    return true;
  const o2 = s(e2);
  return !!o2 && C(o2);
}
function N(e2) {
  if (!e2 || !e2.parentElement || h())
    return document.documentElement;
  let t2 = e2.parentElement;
  for (; t2 && "none" === d(t2, "transform"); )
    t2 = t2.parentElement;
  return t2 || document.documentElement;
}
function P(e2, t2, o2, n2, i2 = false) {
  let r2 = { top: 0, left: 0 };
  const p2 = i2 ? N(e2) : b(e2, a(t2));
  if ("viewport" === n2)
    r2 = D(p2, i2);
  else {
    let o3;
    "scrollParent" === n2 ? (o3 = f(s(t2)), "BODY" === o3.nodeName && (o3 = e2.ownerDocument.documentElement)) : "window" === n2 ? o3 = e2.ownerDocument.documentElement : o3 = n2;
    const d3 = T(o3, p2, i2);
    if ("HTML" === o3.nodeName && !C(p2)) {
      const { height: t3, width: o4 } = v(e2.ownerDocument);
      r2.top += d3.top - d3.marginTop, r2.bottom = t3 + d3.top, r2.left += d3.left - d3.marginLeft, r2.right = o4 + d3.left;
    } else
      r2 = d3;
  }
  o2 = o2 || 0;
  const d2 = "number" == typeof o2;
  return r2.left += d2 ? o2 : o2.left || 0, r2.top += d2 ? o2 : o2.top || 0, r2.right -= d2 ? o2 : o2.right || 0, r2.bottom -= d2 ? o2 : o2.bottom || 0, r2;
}
function B({ width: e2, height: t2 }) {
  return e2 * t2;
}
function H(e2, t2, o2, n2, i2, r2 = 0) {
  if (-1 === e2.indexOf("auto"))
    return e2;
  const p2 = P(o2, n2, r2, i2), d2 = { top: { width: p2.width, height: t2.top - p2.top }, right: { width: p2.right - t2.right, height: p2.height }, bottom: { width: p2.width, height: p2.bottom - t2.bottom }, left: { width: t2.left - p2.left, height: p2.height } }, s2 = Object.keys(d2).map((e3) => O({ key: e3 }, d2[e3], { area: B(d2[e3]) })).sort((e3, t3) => t3.area - e3.area), f2 = s2.filter(({ width: e3, height: t3 }) => e3 >= o2.clientWidth && t3 >= o2.clientHeight), a2 = 0 < f2.length ? f2[0].key : s2[0].key, l2 = e2.split("-")[1];
  return a2 + (l2 ? `-${l2}` : "");
}
function W(e2, t2, o2, n2 = null) {
  const i2 = n2 ? N(t2) : b(t2, a(o2));
  return T(o2, i2, n2);
}
function k(e2) {
  const t2 = e2.ownerDocument.defaultView, o2 = t2.getComputedStyle(e2), n2 = parseFloat(o2.marginTop || 0) + parseFloat(o2.marginBottom || 0), i2 = parseFloat(o2.marginLeft || 0) + parseFloat(o2.marginRight || 0), r2 = { width: e2.offsetWidth + i2, height: e2.offsetHeight + n2 };
  return r2;
}
function A(e2) {
  const t2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
  return e2.replace(/left|right|bottom|top/g, (e3) => t2[e3]);
}
function M(e2, t2, o2) {
  o2 = o2.split("-")[0];
  const n2 = k(e2), i2 = { width: n2.width, height: n2.height }, r2 = -1 !== ["right", "left"].indexOf(o2), p2 = r2 ? "top" : "left", d2 = r2 ? "left" : "top", s2 = r2 ? "height" : "width", f2 = r2 ? "width" : "height";
  return i2[p2] = t2[p2] + t2[s2] / 2 - n2[s2] / 2, i2[d2] = o2 === d2 ? t2[d2] - n2[f2] : t2[A(d2)], i2;
}
function F(e2, t2) {
  return Array.prototype.find ? e2.find(t2) : e2.filter(t2)[0];
}
function I(e2, t2, o2) {
  if (Array.prototype.findIndex)
    return e2.findIndex((e3) => e3[t2] === o2);
  const n2 = F(e2, (e3) => e3[t2] === o2);
  return e2.indexOf(n2);
}
function R(e2, t2, o2) {
  const n2 = void 0 === o2 ? e2 : e2.slice(0, I(e2, "name", o2));
  return n2.forEach((e3) => {
    e3["function"] && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
    const o3 = e3["function"] || e3.fn;
    e3.enabled && p(o3) && (t2.offsets.popper = L(t2.offsets.popper), t2.offsets.reference = L(t2.offsets.reference), t2 = o3(t2, e3));
  }), t2;
}
function U() {
  if (this.state.isDestroyed)
    return;
  let e2 = { instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: false, offsets: {} };
  e2.offsets.reference = W(this.state, this.popper, this.reference, this.options.positionFixed), e2.placement = H(this.options.placement, e2.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e2.originalPlacement = e2.placement, e2.positionFixed = this.options.positionFixed, e2.offsets.popper = M(this.popper, e2.offsets.reference, e2.placement), e2.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute", e2 = R(this.modifiers, e2), this.state.isCreated ? this.options.onUpdate(e2) : (this.state.isCreated = true, this.options.onCreate(e2));
}
function Y(e2, t2) {
  return e2.some(({ name: e3, enabled: o2 }) => o2 && e3 === t2);
}
function V(e2) {
  const t2 = [false, "ms", "Webkit", "Moz", "O"], o2 = e2.charAt(0).toUpperCase() + e2.slice(1);
  for (let n2 = 0; n2 < t2.length; n2++) {
    const i2 = t2[n2], r2 = i2 ? `${i2}${o2}` : e2;
    if ("undefined" != typeof document.body.style[r2])
      return r2;
  }
  return null;
}
function j() {
  return this.state.isDestroyed = true, Y(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[V("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;
}
function K(e2) {
  const t2 = e2.ownerDocument;
  return t2 ? t2.defaultView : window;
}
function q(e2, t2, o2, n2) {
  const i2 = "BODY" === e2.nodeName, r2 = i2 ? e2.ownerDocument.defaultView : e2;
  r2.addEventListener(t2, o2, { passive: true }), i2 || q(f(r2.parentNode), t2, o2, n2), n2.push(r2);
}
function z(e2, t2, o2, n2) {
  o2.updateBound = n2, K(e2).addEventListener("resize", o2.updateBound, { passive: true });
  const i2 = f(e2);
  return q(i2, "scroll", o2.updateBound, o2.scrollParents), o2.scrollElement = i2, o2.eventsEnabled = true, o2;
}
function G() {
  this.state.eventsEnabled || (this.state = z(this.reference, this.options, this.state, this.scheduleUpdate));
}
function _(e2, t2) {
  return K(e2).removeEventListener("resize", t2.updateBound), t2.scrollParents.forEach((e3) => {
    e3.removeEventListener("scroll", t2.updateBound);
  }), t2.updateBound = null, t2.scrollParents = [], t2.scrollElement = null, t2.eventsEnabled = false, t2;
}
function X() {
  this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = _(this.reference, this.state));
}
function J(e2) {
  return "" !== e2 && !isNaN(parseFloat(e2)) && isFinite(e2);
}
function Q(e2, t2) {
  Object.keys(t2).forEach((o2) => {
    let n2 = "";
    -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(o2) && J(t2[o2]) && (n2 = "px"), e2.style[o2] = t2[o2] + n2;
  });
}
function Z(e2, t2) {
  Object.keys(t2).forEach(function(o2) {
    const n2 = t2[o2];
    false === n2 ? e2.removeAttribute(o2) : e2.setAttribute(o2, t2[o2]);
  });
}
function $(e2) {
  return Q(e2.instance.popper, e2.styles), Z(e2.instance.popper, e2.attributes), e2.arrowElement && Object.keys(e2.arrowStyles).length && Q(e2.arrowElement, e2.arrowStyles), e2;
}
function ee(e2, t2, o2, n2, i2) {
  const r2 = W(i2, t2, e2, o2.positionFixed), p2 = H(o2.placement, r2, t2, e2, o2.modifiers.flip.boundariesElement, o2.modifiers.flip.padding);
  return t2.setAttribute("x-placement", p2), Q(t2, { position: o2.positionFixed ? "fixed" : "absolute" }), o2;
}
function te(e2, t2) {
  const { popper: o2, reference: n2 } = e2.offsets, { round: i2, floor: r2 } = Math, p2 = (e3) => e3, d2 = i2(n2.width), s2 = i2(o2.width), f2 = -1 !== ["left", "right"].indexOf(e2.placement), a2 = -1 !== e2.placement.indexOf("-"), l2 = t2 ? f2 || a2 || d2 % 2 == s2 % 2 ? i2 : r2 : p2, m2 = t2 ? i2 : p2;
  return { left: l2(1 == d2 % 2 && 1 == s2 % 2 && !a2 && t2 ? o2.left - 1 : o2.left), top: m2(o2.top), bottom: m2(o2.bottom), right: l2(o2.right) };
}
var oe = e && /Firefox/i.test(navigator.userAgent);
function ne(e2, t2) {
  const { x: o2, y: n2 } = t2, { popper: i2 } = e2.offsets, r2 = F(e2.instance.modifiers, (e3) => "applyStyle" === e3.name).gpuAcceleration;
  void 0 !== r2 && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
  const p2 = void 0 === r2 ? t2.gpuAcceleration : r2, d2 = c(e2.instance.popper), s2 = S(d2), f2 = { position: i2.position }, a2 = te(e2, 2 > window.devicePixelRatio || !oe), l2 = "bottom" === o2 ? "top" : "bottom", m2 = "right" === n2 ? "left" : "right", h2 = V("transform");
  let u2, g2;
  if (g2 = "bottom" == l2 ? "HTML" === d2.nodeName ? -d2.clientHeight + a2.bottom : -s2.height + a2.bottom : a2.top, u2 = "right" == m2 ? "HTML" === d2.nodeName ? -d2.clientWidth + a2.right : -s2.width + a2.right : a2.left, p2 && h2)
    f2[h2] = `translate3d(${u2}px, ${g2}px, 0)`, f2[l2] = 0, f2[m2] = 0, f2.willChange = "transform";
  else {
    const e3 = "bottom" == l2 ? -1 : 1, t3 = "right" == m2 ? -1 : 1;
    f2[l2] = g2 * e3, f2[m2] = u2 * t3, f2.willChange = `${l2}, ${m2}`;
  }
  const b2 = { "x-placement": e2.placement };
  return e2.attributes = O({}, b2, e2.attributes), e2.styles = O({}, f2, e2.styles), e2.arrowStyles = O({}, e2.offsets.arrow, e2.arrowStyles), e2;
}
function ie(e2, t2, o2) {
  const n2 = F(e2, ({ name: e3 }) => e3 === t2), i2 = !!n2 && e2.some((e3) => e3.name === o2 && e3.enabled && e3.order < n2.order);
  if (!i2) {
    const e3 = `\`${t2}\``, n3 = `\`${o2}\``;
    console.warn(`${n3} modifier is required by ${e3} modifier in order to work, be sure to include it before ${e3}!`);
  }
  return i2;
}
function re(e2, t2) {
  if (!ie(e2.instance.modifiers, "arrow", "keepTogether"))
    return e2;
  let o2 = t2.element;
  if ("string" == typeof o2) {
    if (o2 = e2.instance.popper.querySelector(o2), !o2)
      return e2;
  } else if (!e2.instance.popper.contains(o2))
    return console.warn("WARNING: `arrow.element` must be child of its popper element!"), e2;
  const n2 = e2.placement.split("-")[0], { popper: i2, reference: r2 } = e2.offsets, p2 = -1 !== ["left", "right"].indexOf(n2), s2 = p2 ? "height" : "width", f2 = p2 ? "Top" : "Left", a2 = f2.toLowerCase(), l2 = p2 ? "left" : "top", m2 = p2 ? "bottom" : "right", h2 = k(o2)[s2];
  r2[m2] - h2 < i2[a2] && (e2.offsets.popper[a2] -= i2[a2] - (r2[m2] - h2)), r2[a2] + h2 > i2[m2] && (e2.offsets.popper[a2] += r2[a2] + h2 - i2[m2]), e2.offsets.popper = L(e2.offsets.popper);
  const c2 = r2[a2] + r2[s2] / 2 - h2 / 2, u2 = d(e2.instance.popper), g2 = parseFloat(u2[`margin${f2}`]), b2 = parseFloat(u2[`border${f2}Width`]);
  let w2 = c2 - e2.offsets.popper[a2] - g2 - b2;
  return w2 = Math.max(Math.min(i2[s2] - h2, w2), 0), e2.arrowElement = o2, e2.offsets.arrow = { [a2]: Math.round(w2), [l2]: "" }, e2;
}
function pe(e2) {
  if ("end" === e2)
    return "start";
  return "start" === e2 ? "end" : e2;
}
var de = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
var se = de.slice(3);
function fe(e2, t2 = false) {
  const o2 = se.indexOf(e2), n2 = se.slice(o2 + 1).concat(se.slice(0, o2));
  return t2 ? n2.reverse() : n2;
}
var ae = { FLIP: "flip", CLOCKWISE: "clockwise", COUNTERCLOCKWISE: "counterclockwise" };
function le(e2, t2) {
  if (Y(e2.instance.modifiers, "inner"))
    return e2;
  if (e2.flipped && e2.placement === e2.originalPlacement)
    return e2;
  const o2 = P(e2.instance.popper, e2.instance.reference, t2.padding, t2.boundariesElement, e2.positionFixed);
  let n2 = e2.placement.split("-")[0], i2 = A(n2), r2 = e2.placement.split("-")[1] || "", p2 = [];
  switch (t2.behavior) {
    case ae.FLIP:
      p2 = [n2, i2];
      break;
    case ae.CLOCKWISE:
      p2 = fe(n2);
      break;
    case ae.COUNTERCLOCKWISE:
      p2 = fe(n2, true);
      break;
    default:
      p2 = t2.behavior;
  }
  return p2.forEach((d2, s2) => {
    if (n2 !== d2 || p2.length === s2 + 1)
      return e2;
    n2 = e2.placement.split("-")[0], i2 = A(n2);
    const f2 = e2.offsets.popper, a2 = e2.offsets.reference, l2 = Math.floor, m2 = "left" === n2 && l2(f2.right) > l2(a2.left) || "right" === n2 && l2(f2.left) < l2(a2.right) || "top" === n2 && l2(f2.bottom) > l2(a2.top) || "bottom" === n2 && l2(f2.top) < l2(a2.bottom), h2 = l2(f2.left) < l2(o2.left), c2 = l2(f2.right) > l2(o2.right), u2 = l2(f2.top) < l2(o2.top), g2 = l2(f2.bottom) > l2(o2.bottom), b2 = "left" === n2 && h2 || "right" === n2 && c2 || "top" === n2 && u2 || "bottom" === n2 && g2, w2 = -1 !== ["top", "bottom"].indexOf(n2), y2 = !!t2.flipVariations && (w2 && "start" === r2 && h2 || w2 && "end" === r2 && c2 || !w2 && "start" === r2 && u2 || !w2 && "end" === r2 && g2), E2 = !!t2.flipVariationsByContent && (w2 && "start" === r2 && c2 || w2 && "end" === r2 && h2 || !w2 && "start" === r2 && g2 || !w2 && "end" === r2 && u2), x2 = y2 || E2;
    (m2 || b2 || x2) && (e2.flipped = true, (m2 || b2) && (n2 = p2[s2 + 1]), x2 && (r2 = pe(r2)), e2.placement = n2 + (r2 ? "-" + r2 : ""), e2.offsets.popper = O({}, e2.offsets.popper, M(e2.instance.popper, e2.offsets.reference, e2.placement)), e2 = R(e2.instance.modifiers, e2, "flip"));
  }), e2;
}
function me(e2) {
  const { popper: t2, reference: o2 } = e2.offsets, n2 = e2.placement.split("-")[0], i2 = Math.floor, r2 = -1 !== ["top", "bottom"].indexOf(n2), p2 = r2 ? "right" : "bottom", d2 = r2 ? "left" : "top", s2 = r2 ? "width" : "height";
  return t2[p2] < i2(o2[d2]) && (e2.offsets.popper[d2] = i2(o2[d2]) - t2[s2]), t2[d2] > i2(o2[p2]) && (e2.offsets.popper[d2] = i2(o2[p2])), e2;
}
function he(e2, t2, o2, n2) {
  var i2 = Math.max;
  const r2 = e2.match(/((?:\-|\+)?\d*\.?\d*)(.*)/), p2 = +r2[1], d2 = r2[2];
  if (!p2)
    return e2;
  if (0 === d2.indexOf("%")) {
    let e3;
    switch (d2) {
      case "%p":
        e3 = o2;
        break;
      case "%":
      case "%r":
      default:
        e3 = n2;
    }
    const i3 = L(e3);
    return i3[t2] / 100 * p2;
  }
  if ("vh" === d2 || "vw" === d2) {
    let e3;
    return e3 = "vh" === d2 ? i2(document.documentElement.clientHeight, window.innerHeight || 0) : i2(document.documentElement.clientWidth, window.innerWidth || 0), e3 / 100 * p2;
  }
  return p2;
}
function ce(e2, t2, o2, n2) {
  const i2 = [0, 0], r2 = -1 !== ["right", "left"].indexOf(n2), p2 = e2.split(/(\+|\-)/).map((e3) => e3.trim()), d2 = p2.indexOf(F(p2, (e3) => -1 !== e3.search(/,|\s/)));
  p2[d2] && -1 === p2[d2].indexOf(",") && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
  const s2 = /\s*,\s*|\s+/;
  let f2 = -1 === d2 ? [p2] : [p2.slice(0, d2).concat([p2[d2].split(s2)[0]]), [p2[d2].split(s2)[1]].concat(p2.slice(d2 + 1))];
  return f2 = f2.map((e3, n3) => {
    const i3 = (1 === n3 ? !r2 : r2) ? "height" : "width";
    let p3 = false;
    return e3.reduce((e4, t3) => "" === e4[e4.length - 1] && -1 !== ["+", "-"].indexOf(t3) ? (e4[e4.length - 1] = t3, p3 = true, e4) : p3 ? (e4[e4.length - 1] += t3, p3 = false, e4) : e4.concat(t3), []).map((e4) => he(e4, i3, t2, o2));
  }), f2.forEach((e3, t3) => {
    e3.forEach((o3, n3) => {
      J(o3) && (i2[t3] += o3 * ("-" === e3[n3 - 1] ? -1 : 1));
    });
  }), i2;
}
function ue(e2, { offset: t2 }) {
  const { placement: o2, offsets: { popper: n2, reference: i2 } } = e2, r2 = o2.split("-")[0];
  let p2;
  return p2 = J(+t2) ? [+t2, 0] : ce(t2, n2, i2, r2), "left" === r2 ? (n2.top += p2[0], n2.left -= p2[1]) : "right" === r2 ? (n2.top += p2[0], n2.left += p2[1]) : "top" === r2 ? (n2.left += p2[0], n2.top -= p2[1]) : "bottom" === r2 && (n2.left += p2[0], n2.top += p2[1]), e2.popper = n2, e2;
}
function ge(e2, t2) {
  let o2 = t2.boundariesElement || c(e2.instance.popper);
  e2.instance.reference === o2 && (o2 = c(o2));
  const n2 = V("transform"), i2 = e2.instance.popper.style, { top: r2, left: p2, [n2]: d2 } = i2;
  i2.top = "", i2.left = "", i2[n2] = "";
  const s2 = P(e2.instance.popper, e2.instance.reference, t2.padding, o2, e2.positionFixed);
  i2.top = r2, i2.left = p2, i2[n2] = d2, t2.boundaries = s2;
  const f2 = t2.priority;
  let a2 = e2.offsets.popper;
  const l2 = { primary(e3) {
    let o3 = a2[e3];
    return a2[e3] < s2[e3] && !t2.escapeWithReference && (o3 = Math.max(a2[e3], s2[e3])), { [e3]: o3 };
  }, secondary(e3) {
    const o3 = "right" === e3 ? "left" : "top";
    let n3 = a2[o3];
    return a2[e3] > s2[e3] && !t2.escapeWithReference && (n3 = Math.min(a2[o3], s2[e3] - ("right" === e3 ? a2.width : a2.height))), { [o3]: n3 };
  } };
  return f2.forEach((e3) => {
    const t3 = -1 === ["left", "top"].indexOf(e3) ? "secondary" : "primary";
    a2 = O({}, a2, l2[t3](e3));
  }), e2.offsets.popper = a2, e2;
}
function be(e2) {
  const t2 = e2.placement, o2 = t2.split("-")[0], n2 = t2.split("-")[1];
  if (n2) {
    const { reference: t3, popper: i2 } = e2.offsets, r2 = -1 !== ["bottom", "top"].indexOf(o2), p2 = r2 ? "left" : "top", d2 = r2 ? "width" : "height", s2 = { start: { [p2]: t3[p2] }, end: { [p2]: t3[p2] + t3[d2] - i2[d2] } };
    e2.offsets.popper = O({}, i2, s2[n2]);
  }
  return e2;
}
function we(e2) {
  if (!ie(e2.instance.modifiers, "hide", "preventOverflow"))
    return e2;
  const t2 = e2.offsets.reference, o2 = F(e2.instance.modifiers, (e3) => "preventOverflow" === e3.name).boundaries;
  if (t2.bottom < o2.top || t2.left > o2.right || t2.top > o2.bottom || t2.right < o2.left) {
    if (true === e2.hide)
      return e2;
    e2.hide = true, e2.attributes["x-out-of-boundaries"] = "";
  } else {
    if (false === e2.hide)
      return e2;
    e2.hide = false, e2.attributes["x-out-of-boundaries"] = false;
  }
  return e2;
}
function ye(e2) {
  const t2 = e2.placement, o2 = t2.split("-")[0], { popper: n2, reference: i2 } = e2.offsets, r2 = -1 !== ["left", "right"].indexOf(o2), p2 = -1 === ["top", "left"].indexOf(o2);
  return n2[r2 ? "left" : "top"] = i2[o2] - (p2 ? n2[r2 ? "width" : "height"] : 0), e2.placement = A(t2), e2.offsets.popper = L(n2), e2;
}
var Ee = { shift: { order: 100, enabled: true, fn: be }, offset: { order: 200, enabled: true, fn: ue, offset: 0 }, preventOverflow: { order: 300, enabled: true, fn: ge, priority: ["left", "right", "top", "bottom"], padding: 5, boundariesElement: "scrollParent" }, keepTogether: { order: 400, enabled: true, fn: me }, arrow: { order: 500, enabled: true, fn: re, element: "[x-arrow]" }, flip: { order: 600, enabled: true, fn: le, behavior: "flip", padding: 5, boundariesElement: "viewport", flipVariations: false, flipVariationsByContent: false }, inner: { order: 700, enabled: false, fn: ye }, hide: { order: 800, enabled: true, fn: we }, computeStyle: { order: 850, enabled: true, fn: ne, gpuAcceleration: true, x: "bottom", y: "right" }, applyStyle: { order: 900, enabled: true, fn: $, onLoad: ee, gpuAcceleration: void 0 } };
var xe = { placement: "bottom", positionFixed: false, eventsEnabled: true, removeOnDestroy: false, onCreate: () => {
}, onUpdate: () => {
}, modifiers: Ee };
var ve = class {
  constructor(e2, t2, o2 = {}) {
    this.scheduleUpdate = () => requestAnimationFrame(this.update), this.update = r(this.update.bind(this)), this.options = O({}, ve.Defaults, o2), this.state = { isDestroyed: false, isCreated: false, scrollParents: [] }, this.reference = e2 && e2.jquery ? e2[0] : e2, this.popper = t2 && t2.jquery ? t2[0] : t2, this.options.modifiers = {}, Object.keys(O({}, ve.Defaults.modifiers, o2.modifiers)).forEach((e3) => {
      this.options.modifiers[e3] = O({}, ve.Defaults.modifiers[e3] || {}, o2.modifiers ? o2.modifiers[e3] : {});
    }), this.modifiers = Object.keys(this.options.modifiers).map((e3) => O({ name: e3 }, this.options.modifiers[e3])).sort((e3, t3) => e3.order - t3.order), this.modifiers.forEach((e3) => {
      e3.enabled && p(e3.onLoad) && e3.onLoad(this.reference, this.popper, this.options, e3, this.state);
    }), this.update();
    const n2 = this.options.eventsEnabled;
    n2 && this.enableEventListeners(), this.state.eventsEnabled = n2;
  }
  update() {
    return U.call(this);
  }
  destroy() {
    return j.call(this);
  }
  enableEventListeners() {
    return G.call(this);
  }
  disableEventListeners() {
    return X.call(this);
  }
};
ve.Utils = ("undefined" == typeof window ? global : window).PopperUtils, ve.placements = de, ve.Defaults = xe;
var popper_min_default = ve;
export {
  popper_min_default as default
};
//# sourceMappingURL=popper__js_dist_popper__min__js.js.map
